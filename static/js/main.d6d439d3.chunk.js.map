{"version":3,"sources":["Board.module.scss","Button.module.scss","App.module.scss","Button.js","BackgroundPicker.js","PriQueueUtil.js","BoardUtil.js","Board.js","util.js","App.js","index.js","BackgroundPicker.module.scss"],"names":["module","exports","children","className","proxiedProps","cn","styles","button","setBackground","buttonClassName","imageUpload","React","useRef","onUpload","useCallback","e","preventDefault","files","current","FileReader","length","fr","onload","img","Image","src","result","url","width","this","height","readAsDataURL","type","id","uploadInput","ref","onChange","htmlFor","Button","tabIndex","uploadButton","PriQueue","data","compare","a","b","i","_down","item","push","_up","top","bottom","pop","pos","parent","halfLength","bestChild","right","swapTiles","board","row1","col1","row2","col2","temp","indexToCoords","index","dimension","row","Math","floor","col","generateSolved","tiles","blankRow","blankCol","countInversions","array","mergeSort","tempArray","left","inversions","mid","j","k","x","merge","shuffleBoard","random","iCoords","jCoords","blankPos","findBlank","concat","isSolvable","getGoalPosition","tile","manhattan","dim","distance","goal","abs","isGoal","heuristic","linearConflicts","tile1","tile2","goal1","goal2","linearConflict","deepEqual","tiles1","tiles2","createNeighbor","neighborRow","neighborCol","neighbor","JSON","parse","stringify","neighbors","n1","n2","steps","Board","useState","setDimension","showNumbers","setShowNumbers","process","background","setBoard","animation","setAnimation","isSolving","setSolving","isSolvingRef","enableSound","enableSoundRef","boardRef","useEffect","isSolved","useMemo","sound","document","getElementById","moveTile","slideUp","slideDown","slideLeft","slideRight","currentTime","play","Promise","resolve","setTimeout","onClickTile","onClickShuffle","generateRandom","onClickStop","onClickSolve","solution","initial","previous","queue","searchNode","totalProcess","neighborList","nextNeighbor","totalSteps","console","log","reverse","shift","solve","reduce","promise","nextStep","then","reject","catch","backgroundWidth","backgroundHeight","windowWidth","window","innerWidth","setWidth","handleWindowResize","addEventListener","removeEventListener","useViewport","tileSize","min","GUTTER_MD_PX","horizontalOffset","verticalOffset","title","wrapper","map","rowTiles","key","backgroundPositionX","ceil","backgroundPositionY","nonEmpty","onClick","style","backgroundImage","backgroundSize","backgroundPosition","number","controls","controlMainRow","control","main","disabled","warning","BackgroundPicker","setting","App","app","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.d6d439d3.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"title\":\"Board_title__3n2y4\",\"controlHeader\":\"Board_controlHeader__3UorC\",\"wrapper\":\"Board_wrapper__2M_tz\",\"board\":\"Board_board__1_xYi\",\"row\":\"Board_row__2rQfu\",\"tile\":\"Board_tile__SsjB6\",\"nonEmpty\":\"Board_nonEmpty__2f5o1\",\"number\":\"Board_number__Dsl1q\",\"slideUp\":\"Board_slideUp__3swdi\",\"slideDown\":\"Board_slideDown__Wt2iP\",\"slideLeft\":\"Board_slideLeft__1jXS4\",\"slideRight\":\"Board_slideRight__3o5lV\",\"controls\":\"Board_controls__akSZV\",\"controlMainRow\":\"Board_controlMainRow__1VEYs\",\"control\":\"Board_control__2EHGl\",\"main\":\"Board_main__2qcOy\",\"warning\":\"Board_warning__1mEwf\",\"setting\":\"Board_setting__218rZ\",\"footer\":\"Board_footer__oquEg\",\"pulse\":\"Board_pulse__1tAmA\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"button\":\"Button_button__2-QBk\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"App_app__2hTB5\",\"pulse\":\"App_pulse__Aurr4\"};","import cn from 'classnames';\nimport React from 'react';\nimport styles from './Button.module.scss';\n\nexport default function ({ children, className, ...proxiedProps }) {\n  return (\n    <button {...proxiedProps} className={cn(styles.button, className)}>\n      {children}\n    </button>\n  );\n}\n","import cn from 'classnames';\nimport React from 'react';\nimport Button from './Button';\nimport styles from './BackgroundPicker.module.scss';\n\nexport default function ({ setBackground, buttonClassName }) {\n\n  const imageUpload = React.useRef();\n\n  const onUpload = React.useCallback(\n    e => {\n      e.preventDefault();\n      const files = imageUpload.current.files;\n      if (FileReader && files && files.length) {\n        const fr = new FileReader();\n        fr.onload = function () {\n          const img = new Image();\n          img.src = fr.result;\n          img.onload = function () {\n            setBackground({\n              url: fr.result,\n              width: this.width,\n              height: this.height\n            });\n          };\n        };\n        fr.readAsDataURL(files[0]);\n      }\n    },\n    [setBackground]\n  );\n\n  return (\n    <>      \n      <input\n        type=\"file\"\n        id=\"image-bg\"\n        className={styles.uploadInput}\n        ref={imageUpload}\n        onChange={onUpload}\n      />\n      <label htmlFor=\"image-bg\">\n        <Button\n          tabIndex={-1}\n          className={cn(styles.uploadButton, buttonClassName)}>\n          Upload Background\n        </Button>\n      </label>\n    </>\n  );\n}\n","export default class PriQueue {\r\n  /**\r\n   * Khởi tạo một đối tượng hàng đợi ưu tiên.\r\n   * @param {Array} data - Mảng dữ liệu ban đầu (mặc định là mảng rỗng).\r\n   * @param {Function} compare - Hàm so sánh (mặc định là so sánh tăng dần).\r\n   */\r\n  constructor(data = [], compare = (a, b) => (a < b ? -1 : a > b ? 1 : 0)) {\r\n    this.data = data;\r\n    this.length = this.data.length; // Số lượng phần tử hiện có trong hàng đợi.\r\n    this.compare = compare;\r\n\r\n    // Nếu mảng ban đầu không rỗng, tiến hành min-heapify từ phần tử cha cuối cùng lên gốc.\r\n    if (this.length > 0) {\r\n      for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Thêm một phần tử vào hàng đợi.\r\n   * @param {*} item - Phần tử cần thêm vào.\r\n   */\r\n  push(item) {\r\n    this.data.push(item); // Thêm phần tử mới vào cuối mảng.\r\n    this._up(this.length++); // Sắp xếp lại heap bằng cách đẩy phần tử lên.\r\n  }\r\n\r\n  /**\r\n   * Lấy và xóa phần tử nhỏ nhất (đầu hàng đợi).\r\n   * @returns {*} Phần tử nhỏ nhất, hoặc undefined nếu hàng đợi rỗng.\r\n   */\r\n  pop() {\r\n    if (this.length === 0) return undefined;\r\n\r\n    const top = this.data[0]; // Phần tử nhỏ nhất (gốc của heap).\r\n    const bottom = this.data.pop(); // Phần tử cuối cùng của mảng.\r\n\r\n    if (--this.length > 0) {\r\n      this.data[0] = bottom; // Đưa phần tử cuối lên gốc.\r\n      this._down(0); // Sắp xếp lại heap bằng cách đẩy phần tử xuống.\r\n    }\r\n\r\n    return top; // Trả về phần tử nhỏ nhất.\r\n  }\r\n\r\n  /**\r\n   * Lấy phần tử nhỏ nhất mà không xóa nó khỏi hàng đợi.\r\n   * @returns {*} Phần tử nhỏ nhất, hoặc undefined nếu hàng đợi rỗng.\r\n   */\r\n  peek() {\r\n    return this.data[0];\r\n  }\r\n\r\n  /**\r\n   * Sắp xếp lại heap bằng cách đẩy phần tử lên trên.\r\n   * @param {number} pos - Vị trí của phần tử cần đẩy lên.\r\n   */\r\n  _up(pos) {\r\n    const { data, compare } = this;\r\n    const item = data[pos];\r\n\r\n    while (pos > 0) {\r\n      const parent = (pos - 1) >> 1; // Chỉ số của phần tử cha.\r\n      const current = data[parent];\r\n      if (compare(item, current) >= 0) break; // Dừng nếu cha nhỏ hơn con.\r\n\r\n      data[pos] = current; // Đổi chỗ với phần tử cha.\r\n      pos = parent; // Tiếp tục kiểm tra ở vị trí cha.\r\n    }\r\n\r\n    data[pos] = item; // gán giá trị ban đầu cho lần đổi vị trí cuối cùng.\r\n  }\r\n\r\n  /**\r\n   * min heapify bằng cách đẩy phần tử giá trị lớn hơn xuống dưới.\r\n   * @param {number} pos - Vị trí của phần tử cần đẩy xuống.\r\n   */\r\n  _down(pos) {\r\n    const { data, compare } = this;\r\n    const halfLength = this.length >> 1; // Điểm dừng là nửa độ dài của mảng.\r\n    const item = data[pos]; // lưu giá trị ở vị trí ban đầu\r\n\r\n    while (pos < halfLength) {\r\n      let bestChild = (pos << 1) + 1; // Ban đầu là con trái.\r\n      const right = bestChild + 1;\r\n\r\n      // Nếu có con phải và con phải nhỏ hơn con trái, chọn con phải.\r\n      if (right < this.length && compare(data[right], data[bestChild]) < 0) {\r\n        bestChild = right;\r\n      }\r\n\r\n      // Nếu phần tử con nhỏ hơn phần tử hiện tại, đổi chỗ.\r\n      if (compare(data[bestChild], item) >= 0) break;\r\n\r\n      data[pos] = data[bestChild]; // Đổi chỗ với phần tử con.\r\n      pos = bestChild; // Tiếp tục kiểm tra ở vị trí con.\r\n    }\r\n\r\n    data[pos] = item; // gán giá trị ban đầu cho lần đổi vị trí cuối cùng.\r\n  }\r\n}\r\n","import PriQueue from \"./PriQueueUtil\"; // hàng đợi ưu tiên\r\n\r\n// Hoán đổi hai ô trên bảng 2d\r\nexport function swapTiles(board, row1, col1, row2, col2) {\r\n  const temp = board[row1][col1];\r\n  board[row1][col1] = board[row2][col2];\r\n  board[row2][col2] = temp;\r\n}\r\n\r\n//Tìm vị trí ô trống trên bảng 2d\r\nfunction findBlank(board) {\r\n  const dimension = board.length;\r\n  for (let row = 0; row < dimension; row++) {\r\n    for (let col = 0; col < dimension; col++) {\r\n      if (board[row][col] === 0) return { row, col };\r\n    }\r\n  }\r\n}\r\n\r\n//Chuyển đổi chỉ số của 1d sang 2d\r\nfunction indexToCoords(index, dimension) {\r\n  return {\r\n    row: Math.floor(index / dimension),\r\n    col: index % dimension,\r\n  };\r\n}\r\n\r\n// Tạo bảng đã giải\r\nexport function generateSolved(dimension) {\r\n  let tiles = [];\r\n  for (let row = 0; row < dimension; row++) {\r\n    tiles[row] = [];\r\n    for (let col = 0; col < dimension; col++) {\r\n      tiles[row][col] = row * dimension + col + 1;\r\n    }\r\n  }\r\n  tiles[dimension - 1][dimension - 1] = 0;\r\n  return { tiles: tiles, blankRow: dimension - 1, blankCol: dimension - 1 };\r\n}\r\n\r\n// các hàm xử lý đảm bảo bài toán có thể giải được sau khi trộn\r\n// số nghịch đảo là lượng cặp (i,j) i< j a[i] > a[j]\r\n// Hợp nhất hai mảng đã sắp xếp array[left..mid] và array[mid+1..right] vào tempArray theo thứ tự tăng dần và đếm số nghịch đảo\r\nfunction merge(array, tempArray, left, mid, right) {\r\n  let inversions = 0;\r\n  let i = left;\r\n  let j = mid + 1;\r\n  let k = left;\r\n  // So sánh và hợp nhất\r\n  while (i <= mid && j <= right) {\r\n    if (array[i] <= array[j]) {\r\n      tempArray[k] = array[i];\r\n      k++;\r\n      i++;\r\n    } else {\r\n      tempArray[k] = array[j];\r\n      // Không tính ô trống\r\n      if (array[j] !== 0) inversions += mid - i + 1; // phần tử thuộc mảng con phải nhỏ hơn toàn bộ phần tử từ i đến mid\r\n      k++;\r\n      j++;\r\n    }\r\n  }\r\n\r\n  while (i <= mid) {\r\n    tempArray[k] = array[i];\r\n    k++;\r\n    i++;\r\n  }\r\n  while (j <= right) {\r\n    tempArray[k] = array[j];\r\n    k++;\r\n    j++;\r\n  }\r\n\r\n  for (let x = left; x <= right; x++) array[x] = tempArray[x];\r\n\r\n  return inversions;\r\n}\r\n\r\n// Hàm MergeSort để đếm số nghịch đảo trong mảng\r\nfunction mergeSort(array, tempArray, left, right) {\r\n  let inversions = 0;\r\n\r\n  if (left < right) {\r\n    const mid = Math.floor((left + right) / 2);\r\n    inversions += mergeSort(array, tempArray, left, mid);\r\n    inversions += mergeSort(array, tempArray, mid + 1, right);\r\n    inversions += merge(array, tempArray, left, mid, right);\r\n  }\r\n\r\n  return inversions;\r\n}\r\n\r\n// Đếm số nghịch đảo trong mảng\r\nexport function countInversions(array) {\r\n  return mergeSort(array, [], 0, array.length - 1);\r\n}\r\n\r\n// Kiểm tra bảng có thể giải được hay không\r\nexport function isSolvable(tiles, blankRow) {\r\n  const dimension = tiles.length;\r\n  const flattenedBoard = [].concat(...tiles); // 2d to 1d\r\n  const inversions = countInversions(flattenedBoard);\r\n  if (dimension % 2 === 1) return inversions % 2 === 0;\r\n  else if (blankRow % 2 === 0) return inversions % 2 === 1;\r\n  return inversions % 2 === 0;\r\n}\r\n\r\n// Trộn các ô của bảng theo thứ tự ngẫu nhiên và đảm bảo bảng có thể giải được\r\nfunction shuffleBoard(tiles) {\r\n  const dimension = tiles.length;\r\n  const size = dimension * dimension - 1;\r\n\r\n  // Thuật toán Fisher-Yates để trộn ngẫu nhiên các ô\r\n  for (let i = size; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * i); // j thuộc từ 0 đến i-1\r\n    const iCoords = indexToCoords(i, dimension);\r\n    const jCoords = indexToCoords(j, dimension);\r\n    swapTiles(tiles, iCoords.row, iCoords.col, jCoords.row, jCoords.col); // đổi chỗ ô i và ô j\r\n  }\r\n\r\n  const blankPos = findBlank(tiles);\r\n  if (!isSolvable(tiles, blankPos.row)) {\r\n    // Nếu bảng không thể giải, tăng/giảm số nghịch đảo 1đv để đảm bảo solvable\r\n    if (blankPos.row === 0)\r\n      swapTiles(tiles, 1, 0, 1, 1); // đảm bảo ko hoán vị ô trống\r\n    else swapTiles(tiles, 0, 0, 0, 1);\r\n  }\r\n\r\n  return { tiles: tiles, blankRow: blankPos.row, blankCol: blankPos.col };\r\n}\r\n\r\n//Lấy vị trí mục tiêu của một ô trong bảng\r\nexport function getGoalPosition(tile, dimension) {\r\n  return indexToCoords(tile - 1, dimension);\r\n}\r\n\r\n//Tính tổng khoảng cách Manhattan từ các ô đến vị trí mục tiêu của chúng\r\nexport function manhattan(tiles) {\r\n  const dim = tiles.length;\r\n  let distance = 0;\r\n  for (let row = 0; row < dim; row++) {\r\n    // duyệt toàn bộ các ô\r\n    for (let col = 0; col < dim; col++) {\r\n      const tile = tiles[row][col];\r\n      if (tile === 0) continue;\r\n      const goal = getGoalPosition(tile, dim);\r\n      distance += Math.abs(goal.row - row) + Math.abs(goal.col - col); // công thức tính khoảng cách manhattan\r\n    }\r\n  }\r\n  return distance;\r\n}\r\n\r\n//Kiểm tra bảng hiện tại có đạt trạng thái mục tiêu\r\nexport function isGoal(tiles) {\r\n  return manhattan(tiles) === 0;\r\n}\r\n\r\n// Tính số lượng xung đột tuyến tính(2 ô cùng nằm trong hàng/cột và vị trí mục tiêu cũng cùng hàng/cột nhưng vị trí của chúng cản trở lẫn nhau)\r\nexport function linearConflict(tiles) {\r\n  const dim = tiles.length;\r\n\r\n  let linearConflicts = 0;\r\n\r\n  for (let row = 0; row < dim; row++) {\r\n    // duyệt qua các hàng để kiểm tra\r\n    for (let col1 = 0; col1 < dim; col1++) {\r\n      // duyệt toàn bộ các cặp ô trong hàng\r\n      for (let col2 = col1; col2 < dim; col2++) {\r\n        const tile1 = tiles[row][col1];\r\n        const tile2 = tiles[row][col2];\r\n        if (tile1 === 0 || tile2 === 0) continue; // bỏ ô trống\r\n        const goal1 = getGoalPosition(tile1, dim);\r\n        const goal2 = getGoalPosition(tile2, dim);\r\n        if (goal1.row === row && goal2.row === row && goal1.col > goal2.col)\r\n          //thứ tự 2 ô gây cản trở\r\n          linearConflicts++;\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let col = 0; col < dim; col++) {\r\n    // tương tự với cột\r\n    for (let row1 = 0; row1 < dim; row1++) {\r\n      for (let row2 = row1; row2 < dim; row2++) {\r\n        const tile1 = tiles[row1][col];\r\n        const tile2 = tiles[row2][col];\r\n        if (tile1 === 0 || tile2 === 0) continue;\r\n        const goal1 = getGoalPosition(tile1, dim);\r\n        const goal2 = getGoalPosition(tile2, dim);\r\n        if (goal1.col === col && goal2.col === col && goal1.row > goal2.row)\r\n          linearConflicts++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return linearConflicts;\r\n}\r\n\r\n// Hàm heuristic kết hợp Manhattan và xung đột tuyến tính\r\nexport function heuristic(tiles) {\r\n  return manhattan(tiles) + 2 * linearConflict(tiles);\r\n}\r\n\r\n// So sánh hai bảng\r\nexport function deepEqual(tiles1, tiles2) {\r\n  if (tiles1.length !== tiles2.length) return false;\r\n  for (let row = 0; row < tiles1.length; row++) {\r\n    for (let col = 0; col < tiles1.length; col++) {\r\n      if (tiles1[row][col] !== tiles2[row][col]) return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// Tạo một bảng hàng xóm\r\nfunction createNeighbor(tiles, blankRow, blankCol, neighborRow, neighborCol) {\r\n  swapTiles(tiles, blankRow, blankCol, neighborRow, neighborCol); // hoán vị ô trống\r\n  const neighbor = JSON.parse(JSON.stringify(tiles)); // tạo bản sao hàng xóm là 1 hoán vị\r\n  swapTiles(tiles, blankRow, blankCol, neighborRow, neighborCol); // đưa bảng về trạng thái cũ\r\n  return { tiles: neighbor, blankRow: neighborRow, blankCol: neighborCol };\r\n}\r\n\r\n//Tạo các bảng hàng xóm bằng cách di chuyển ô trống lên xuống trái phải\r\nexport function neighbors(tiles, blankRow, blankCol) {\r\n  let neighbors = [];\r\n\r\n  if (blankRow > 0) {\r\n    neighbors.push(\r\n      createNeighbor(tiles, blankRow, blankCol, blankRow - 1, blankCol)\r\n    );\r\n  }\r\n  if (blankCol > 0) {\r\n    neighbors.push(\r\n      createNeighbor(tiles, blankRow, blankCol, blankRow, blankCol - 1)\r\n    );\r\n  }\r\n  if (blankRow < tiles.length - 1) {\r\n    neighbors.push(\r\n      createNeighbor(tiles, blankRow, blankCol, blankRow + 1, blankCol)\r\n    );\r\n  }\r\n  if (blankCol < tiles.length - 1) {\r\n    neighbors.push(\r\n      createNeighbor(tiles, blankRow, blankCol, blankRow, blankCol + 1)\r\n    );\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\n//Sinh bảng ngẫu nhiên có thể giải được\r\nexport function generateRandom(dimension) {\r\n  return shuffleBoard(generateSolved(dimension).tiles);\r\n}\r\n\r\n// Hàm so sánh hai nút trong hàng đợi ưu tiên\r\nfunction compare(n1, n2) {\r\n  const priority1 = n1.heuristic * 2 + n1.steps;\r\n  const priority2 = n2.heuristic * 2 + n2.steps;\r\n  return priority1 - priority2;\r\n}\r\n\r\n//  thuật toán  A*\r\nexport function solve(tiles, blankRow, blankCol) {\r\n  const initial = {\r\n    tiles,\r\n    blankRow,\r\n    blankCol,\r\n    heuristic: heuristic(tiles),\r\n    steps: 0,\r\n    previous: null,\r\n  };\r\n  const queue = new PriQueue([initial], compare); // thêm trạng thái ban đầu vào hàng đợi ưu tiên\r\n  let searchNode = initial;\r\n  let totalProcess = 0;\r\n  while (!isGoal(searchNode.tiles)) {\r\n    // chưa đạt trạng thái giải\r\n    searchNode = queue.pop(); // lấy trạng thái tốt nhất từ hàng đợi ưu tiên dựa trên heuristic + steps\r\n    totalProcess++;\r\n\r\n    const neighborList = neighbors(\r\n      // tạo các trạng thái liền kề\r\n      searchNode.tiles,\r\n      searchNode.blankRow,\r\n      searchNode.blankCol\r\n    );\r\n    for (let i = 0; i < neighborList.length; i++) {\r\n      // đẩy các trạng thái liền kề vào hàng đợi ưu tiên\r\n      const nextNeighbor = neighborList[i];\r\n\r\n      // Bỏ qua nếu bảng giống bảng trước đó\r\n      if (\r\n        searchNode.previous !== null &&\r\n        deepEqual(nextNeighbor.tiles, searchNode.previous.tiles)\r\n      ) {\r\n        continue; // tránh lặp lại vị trí đã có trước đó\r\n      }\r\n\r\n      queue.push({\r\n        tiles: nextNeighbor.tiles,\r\n        blankRow: nextNeighbor.blankRow,\r\n        blankCol: nextNeighbor.blankCol,\r\n        heuristic: heuristic(nextNeighbor.tiles),\r\n        steps: searchNode.steps + 1,\r\n        previous: searchNode,\r\n      });\r\n    }\r\n  }\r\n  let totalSteps = searchNode.steps;\r\n  console.log(\"Solution Steps By A*:\", totalSteps);\r\n  console.log(\"Solution Process By A*:\", totalProcess);\r\n\r\n  // Lưu chuỗi bước di chuyển\r\n  const solution = [];\r\n  while (searchNode !== null) {\r\n    solution.push({\r\n      blankRow: searchNode.blankRow,\r\n      blankCol: searchNode.blankCol,\r\n    });\r\n    searchNode = searchNode.previous;\r\n  }\r\n\r\n  solution.reverse(); // đảo ngược để mảng lưu từ trạng thái nguồn đến trạng thái đích\r\n  solution.shift(); // bỏ trạng thái đầu tiên\r\n  return solution;\r\n}\r\n\r\nexport function solveVisitedSet(tiles, blankRow, blankCol) {\r\n  const initial = {\r\n    tiles,\r\n    blankRow,\r\n    blankCol,\r\n    heuristic: heuristic(tiles),\r\n    steps: 0,\r\n    previous: null,\r\n  };\r\n  const queue = new PriQueue([initial], compare); // thêm trạng thái ban đầu vào hàng đợi ưu tiên\r\n  const visited = new Set();\r\n  let searchNode = initial;\r\n  let totalProcess = 0;\r\n  while (!isGoal(searchNode.tiles)) {\r\n    // chưa đạt trạng thái giải\r\n    searchNode = queue.pop(); // lấy trạng thái tốt nhất từ hàng đợi ưu tiên dựa trên heuristic + steps\r\n    totalProcess++;\r\n    const stateKey = JSON.stringify(searchNode.tiles);\r\n    if (visited.has(stateKey)) continue; // Bỏ qua nếu trạng thái đã xử lý\r\n    visited.add(stateKey); // Đánh dấu trạng thái đã xử lý\r\n\r\n    const neighborList = neighbors(\r\n      // tạo các trạng thái liền kề\r\n      searchNode.tiles,\r\n      searchNode.blankRow,\r\n      searchNode.blankCol\r\n    );\r\n    for (let i = 0; i < neighborList.length; i++) {\r\n      // đẩy các trạng thái liền kề vào hàng đợi ưu tiên\r\n      const nextNeighbor = neighborList[i];\r\n      // Bỏ qua nếu trạng thái đã được xử lý\r\n      const neighborKey = JSON.stringify(nextNeighbor.tiles);\r\n      if (visited.has(neighborKey)) continue;\r\n\r\n      // Bỏ qua nếu bảng giống bảng trước đó\r\n\r\n      queue.push({\r\n        tiles: nextNeighbor.tiles,\r\n        blankRow: nextNeighbor.blankRow,\r\n        blankCol: nextNeighbor.blankCol,\r\n        heuristic: heuristic(nextNeighbor.tiles),\r\n        steps: searchNode.steps + 1,\r\n        previous: searchNode,\r\n      });\r\n    }\r\n  }\r\n  let totalSteps = searchNode.steps;\r\n  console.log(\"Solution Steps By A* with visited set:\", totalSteps);\r\n  console.log(\"Solution Process By A* with visited set:\", totalProcess);\r\n  \r\n  // Lưu chuỗi bước di chuyển\r\n  const solution = [];\r\n  while (searchNode !== null) {\r\n    solution.push({\r\n      blankRow: searchNode.blankRow,\r\n      blankCol: searchNode.blankCol,\r\n    });\r\n    searchNode = searchNode.previous;\r\n  }\r\n\r\n  solution.reverse(); // đảo ngược để mảng lưu từ trạng thái nguồn đến trạng thái đích\r\n  solution.shift(); // bỏ trạng thái đầu tiên\r\n  return { solution, totalSteps };\r\n}\r\n\r\n\r\n","import cn from \"classnames\";\nimport React from \"react\";\nimport BackgroundPicker from \"./BackgroundPicker\";\nimport Button from \"./Button\";\nimport { useViewport } from \"./util\";\nimport { GUTTER_MD_PX } from \"./util\";\nimport styles from \"./Board.module.scss\";\nimport {\n  swapTiles,\n  generateSolved,\n  generateRandom,\n  getGoalPosition,\n  solve,\n  isGoal,\n} from \"./BoardUtil\";\n\nconst ANIMATION_MS = 250;\nconst MAX_TILE_PX = 100;\nconst MIN_DIMENSION = 3;\nconst MAX_DIMENSION = 4;\nconst DEFAULT_DIMENSION = 3;\n\nexport default function Board() {\n  const [dimension, setDimension] = React.useState(DEFAULT_DIMENSION);\n  const [showNumbers, setShowNumbers] = React.useState(true);\n  const [background, setBackground] = React.useState({\n    url: process.env.PUBLIC_URL + \"/background.jpg\",\n    width: 960,\n    height: 720,\n  });\n\n  let [board, setBoard] = React.useState(generateSolved(dimension));\n  let [animation, setAnimation] = React.useState({\n    animation: null,\n    row: null,\n    col: null,\n  });\n\n  // Các ref đảm bảo rằng callback hoạt động luôn với trạng thái mới nhất\n  // https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function\n\n  const [isSolving, setSolving] = React.useState(false); // Để hiển thị chính xác trạng thái trên nút\n  const isSolvingRef = React.useRef(isSolving); // Kiểm tra xem có thực sự chạy giải pháp không\n\n  const [enableSound, setEnableSound] = React.useState(true);\n  const enableSoundRef = React.useRef(enableSound);\n\n  const boardRef = React.useRef(board);\n  boardRef.current = board;\n\n  // Tái tạo lại bảng khi thay đổi kích thước bảng\n  React.useEffect(() => setBoard(generateSolved(dimension)), [dimension]);\n\n  const isSolved = React.useMemo(() => isGoal(board.tiles), [board]);\n\n  const sound = React.useMemo(() => {\n    return document.getElementById(\"sound-tile\");\n  }, []);\n\n  const moveTile = React.useCallback(\n    (row, col) => {\n      const { blankRow, blankCol } = boardRef.current;\n\n      let animation;\n      if (row - 1 === blankRow) animation = styles.slideUp;\n      else if (row + 1 === blankRow) animation = styles.slideDown;\n      else if (col - 1 === blankCol) animation = styles.slideLeft;\n      else animation = styles.slideRight;\n\n      // Chạy animation\n      setAnimation({ animation, row, col });\n\n      // Phát âm thanh (trừ khi đang chạy giải pháp tự động)\n      if (enableSoundRef.current && !isSolvingRef.current) {\n        sound.currentTime = 0;\n        sound.play();\n      }\n\n      // Sau khi ANIMATION_MS trôi qua, dọn dẹp\n      return new Promise((resolve) => {\n        setTimeout(() => {\n          // Dừng animation\n          setAnimation({ animation: null, row: null, col: null });\n\n          // Cập nhật trạng thái\n          swapTiles(\n            boardRef.current.tiles,\n            row,\n            col,\n            boardRef.current.blankRow,\n            boardRef.current.blankCol\n          );\n          setBoard({\n            tiles: boardRef.current.tiles,\n            blankRow: row,\n            blankCol: col,\n          });\n\n          resolve();\n        }, ANIMATION_MS);\n      });\n    },\n    [boardRef, sound, enableSoundRef]\n  );\n\n  const onClickTile = React.useCallback(\n    (row, col) => {\n      // Bỏ qua click khi đang có animation hoặc giải pháp tự động đang chạy\n      if (animation.animation || isSolvingRef.current) return Promise.resolve();\n\n      // Bỏ qua click trên các ô không nằm cạnh ô trống\n      const { blankRow, blankCol } = boardRef.current;\n      const isValidMove =\n        (blankRow === row && Math.abs(blankCol - col) === 1) ||\n        (blankCol === col && Math.abs(blankRow - row) === 1);\n      if (!isValidMove) return Promise.resolve();\n\n      return moveTile(row, col);\n    },\n    [animation, isSolvingRef, boardRef, moveTile]\n  );\n\n  const onClickShuffle = React.useCallback(() => {\n    setBoard(generateRandom(dimension));\n  }, [dimension]);\n\n  const onClickStop = React.useCallback(() => {\n    setSolving(false);\n    isSolvingRef.current = false;\n  }, []);\n\n  const onClickSolve = React.useCallback(() => {\n    const solution = solve(board.tiles, board.blankRow, board.blankCol);\n\n    setSolving(true);\n    isSolvingRef.current = true;\n\n    // Kết nối các bước giải quyết thành chuỗi các promise thực hiện lần lượt\n    solution\n      .reduce(\n        (promise, nextStep) =>\n          promise.then(() => {\n            // Chạy bước giải pháp tiếp theo nếu \"isSolving\" vẫn là true.\n            // Nếu không, hủy các bước tiếp theo.\n            if (isSolvingRef.current)\n              return moveTile(nextStep.blankRow, nextStep.blankCol);\n            else return Promise.reject();\n          }),\n        Promise.resolve()\n      )\n      .catch(() => {\n        /* bỏ qua lỗi từ nút Stop */\n      })\n      .then(() => {\n        setSolving(false);\n        isSolvingRef.current = false;\n      });\n  }, [isSolvingRef, board, moveTile]);\n\n  // Phù hợp với kích thước nhỏ hơn (style \"cover\" cho background)\n  const backgroundWidth = React.useMemo(() => {\n    if (!background || background.width < background.height)\n      return 100 * dimension;\n    return 100 * (background.width / background.height) * dimension;\n  }, [background, dimension]);\n  const backgroundHeight = React.useMemo(() => {\n    if (!background || background.height < background.width)\n      return 100 * dimension;\n    return 100 * (background.height / background.width) * dimension;\n  }, [background, dimension]);\n\n  const windowWidth = useViewport().width;\n  const tileSize = React.useMemo(() => {\n    // Trên các màn hình nhỏ, điều chỉnh kích thước ô để lấp đầy chiều rộng của cửa sổ trừ khoảng cách padding\n    return Math.min(\n      MAX_TILE_PX,\n      (windowWidth - GUTTER_MD_PX * 2) / MAX_DIMENSION\n    );\n  }, [windowWidth]);\n\n  // Tính toán độ lệch để căn giữa cho các background không phải vuông. Chuyển phần dư % thành pixel\n  const horizontalOffset = React.useMemo(() => {\n    if (!background || background.height > background.width) return 0;\n    return (\n      ((background.width / background.height - 1) / 2) * dimension * tileSize\n    );\n  }, [background, dimension, tileSize]);\n  const verticalOffset = React.useMemo(() => {\n    if (!background || background.width > background.height) return 0;\n    return (\n      ((background.height / background.width - 1) / 2) * dimension * tileSize\n    );\n  }, [background, dimension, tileSize]);\n\n  return (\n    <>\n      <h1 className={styles.title}>Sliding Puzzle</h1>\n      <div className={styles.wrapper}>\n        <div className={styles.board}>\n          {board.tiles.map((rowTiles, row) => (\n            <div className={styles.row} key={row}>\n              {rowTiles.map((tile, col) => {\n                const goal = getGoalPosition(tile, dimension);\n\n                // Sử dụng vị trí mục tiêu để tính toán background\n                const backgroundPositionX = Math.ceil(\n                  goal.col * -tileSize - horizontalOffset\n                );\n                const backgroundPositionY = Math.ceil(\n                  goal.row * -tileSize - verticalOffset\n                );\n\n                return (\n                  <div\n                    className={cn([\n                      styles.tile,\n                      {\n                        [styles.nonEmpty]: tile !== 0,\n                        [animation.animation]:\n                          animation.row === row && animation.col === col,\n                      },\n                    ])}\n                    key={col}\n                    onClick={() => onClickTile(row, col)}\n                    style={\n                      tile !== 0\n                        ? {\n                            width: tileSize,\n                            height: tileSize,\n                            backgroundImage:\n                              background && `url(\"${background.url}\")`,\n                            backgroundSize: `${backgroundWidth}% ${backgroundHeight}%`,\n                            backgroundPosition: `${backgroundPositionX}px ${backgroundPositionY}px`,\n                          }\n                        : {\n                            width: tileSize,\n                            height: tileSize,\n                          }\n                    }\n                  >\n                    {tile !== 0 && showNumbers && (\n                      <div className={styles.number}>{tile}</div>\n                    )}\n                  </div>\n                );\n              })}\n            </div>\n          ))}\n        </div>\n        <div className={styles.controls}>\n          <div className={styles.controlMainRow}>\n            <Button\n              className={cn(styles.control, styles.main)}\n              disabled={isSolving}\n              onClick={onClickShuffle}\n              type=\"button\"\n            >\n              Shuffle\n            </Button>\n            <Button\n              className={cn(styles.control, styles.main, {\n                [styles.warning]: isSolving,\n              })}\n              disabled={isSolved}\n              onClick={isSolving ? onClickStop : onClickSolve}\n              type=\"button\"\n            >\n              {isSolving ? \"Stop\" : \"Solve\"}\n            </Button>\n          </div>\n          <div>\n            <BackgroundPicker\n              buttonClassName={styles.control}\n              setBackground={setBackground}\n            />\n          </div>\n\n          <div>\n            <Button\n              className={cn(styles.control, styles.setting)}\n              disabled={isSolving}\n              onClick={() => {\n                if (dimension >= MAX_DIMENSION) setDimension(MIN_DIMENSION);\n                else setDimension(dimension + 1);\n              }}\n            >\n              {dimension >= MAX_DIMENSION ? <p>3x3</p> : <p>4x4</p>}\n            </Button>\n            <Button\n              className={cn(styles.control, styles.setting, {\n                [styles.warning]: !showNumbers,\n              })}\n              onClick={() => setShowNumbers(!showNumbers)}\n            >\n              {showNumbers ? <p>Hide Numbers</p> : <p>Show Numbers</p>}\n            </Button>\n          </div>\n        </div>\n      </div>\n    </>\n  );\n}\n","import React from 'react';\n\nexport const GUTTER_MD_PX = 16;\nexport const GUTTER_LG_PX = 24;\n\nexport function useViewport() {\n  const [width, setWidth] = React.useState(window.innerWidth);\n\n  React.useEffect(() => {\n    const handleWindowResize = () => setWidth(window.innerWidth);\n    window.addEventListener('resize', handleWindowResize);\n    return () => window.removeEventListener('resize', handleWindowResize);\n  }, []);\n\n  return { width };\n}\n","import React from 'react';\nimport Board from './Board';\nimport styles from './App.module.scss';\n\nexport default function App() {\n  return (\n    <div className={styles.app}>\n      <Board />\n      <div id=\"modal-root\"></div>\n    </div>\n  );\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"BackgroundPicker_header__3Zadt\",\"uploadInput\":\"BackgroundPicker_uploadInput__bqdYL\",\"uploadButton\":\"BackgroundPicker_uploadButton__1VuVV\",\"pulse\":\"BackgroundPicker_pulse__LrI4U\"};"],"sourceRoot":""}